/*
 Copyright (c) 2023 by ScaleOut Software, Inc.

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/
package com.scaleoutsoftware.digitaltwin.development;

import com.scaleoutsoftware.digitaltwin.core.*;

import java.io.*;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentLinkedQueue;

/**
 * The Workbench is used to represent an environment where developers can test real-time and simulated digital twins.
 * <p>
 * <b>Quick start:</b>
 * </p>
 * <p>
 * Build a real-time digital twin model for testing real-time message processing with messages generated by a simulated
 * digital twin.
 * </p>
 * <p>
 *     The real-time model will represent a car and the simulated digital twin will
 *     represent a pump increasing the real-time car's tire pressure. The real-time car will process messages from the
 *     simulated pump and send information back to the simulated pump when the tire is full.
 * </p>
 *
 * <p>The quickstart will demonstrate the following: </p>
 * <ul>
 *     <li>Define a real-time car digital twin</li>
 *     <li>Define a tire pressure change message</li>
 *     <li>Define a real-time car message processor</li>
 *     <li>Define a simulated pump digital twin</li>
 *     <li>Define a simulated pump message processor</li>
 *     <li>Define a simulated pump simulation processor</li>
 * </ul>
 *
 * <p>
 * <b>Defining the real-time car model:</b>
 * </p>
 *
 * <p>
 *     Create a class that extends the {@link DigitalTwinBase} class and add an integer property for tire pressure.
 *     When constructed by the {@link Workbench} this will be our real-time car instance.
 * </p>
 * <pre>
 *     public class RealTimeCar extends DigitalTwinBase {
 *         private int _tirePressure;
 *         public RealTimeCar() { _tirePressure=0; }
 *         public RealTimeCar(int startingTirePressure) {
 *             _tirePressure = startingTirePressure;
 *         }
 *
 *         public void incrementTirePressure(int increment) {
 *             _tirePressure += increment;
 *         }
 *
 *         public int getTirePressure() {
 *             return _tirePressure;
 *         }
 *     }
 * </pre>
 * <p>
 * <b>Defining the tire pressure change message:</b>
 * </p>
 * <p>
 *     Implement a message to send from the simulated pump, to the real-time model. The message will tell the real-time
 *     car to increase the tire pressure by some value.
 * </p>
 *
 * <pre>
 *     public class TirePressureMessage {
 *         final int _pressureChange;
 *         public TirePressureMessage(int pressureChange) {
 *             _pressureChange = pressureChange;
 *         }
 *
 *         public int getPressureChange() {
 *             return _pressureChange;
 *         }
 *     }
 * </pre>
 *
 * <p>
 * <b>Defining the real-time car message processor:</b>
 * </p>
 *
 * <p>
 *     Create the real-time car {@link MessageProcessor}. The message processor will apply the tire pressure change from the tire
 *     pressure message to the real-time car digital twin instance. When the tire is full, the message processor will
 *     send a message back to the simulated pump.
 * </p>
 * <pre>
 *     public class RealTimeCarMessageProcessor extends MessageProcessor{@literal <}RealTimeCar, TirePressureMessage{@literal >} implements Serializable {
 *         final int TIRE_PRESSURE_FULL = 100;
 *         public ProcessingResult processMessages(ProcessingContext processingContext, RealTimeCar car, Iterable{@literal <}TirePressureMessage{@literal >} messages) throws Exception {
 *             // apply the updates from the messages
 *             for(TirePressureMessage message : messages) {
 *                 car.incrementTirePressure(message.getPressureChange());
 *             }
 *             if(car.getTirePressure() {@literal >} TIRE_PRESSURE_FULL) {
 *                 processingContext.sendToDataSource(new TirePressureMessage(car.getTirePressure()));
 *             }
 *             return ProcessingResult.UpdateDigitalTwin;
 *         }
 *     }
 * </pre>
 *
 * <p>
 * <b>Defining the simulated pump model:</b>
 * </p>
 *
 * <p>
 *     Create a class that extends the {@link DigitalTwinBase} class and add a double property for tire pressure change.
 *     When constructed by the {@link Workbench} this will be our simulated pump instance.
 * </p>
 * <pre>
 *     public class SimulatedPump extends DigitalTwinBase {
 *     private double _tirePressureChange;
 *     private boolean _tirePressureReached = false;
 *     public SimulatedPump() {}
 *     public SimulatedPump(double pressureChange) {
 *         _tirePressureChange = pressureChange;
 *     }
 *
 *     public double getTirePressureChange() {
 *         return _tirePressureChange;
 *     }
 *
 *     public void setTirePressureReached() {
 *         _tirePressureReached = true;
 *     }
 *
 *     public boolean isTireFull() {
 *         return _tirePressureReached;
 *     }
 * }
 * </pre>
 *
 * <p>
 * <b>Defining the simulated pump message processor:</b>
 * </p>
 *
 * <p>
 *     The simulated pump should stop when the simulated pump message processor receives a message. The simulated pump message
 *     processor will update the state of the simulated pump indicating that the tire is full.
 * </p>
 * <pre>
 *     public class PumpMessageProcessor extends MessageProcessor{@literal <}SimulatedPump, TirePressureMessage{@literal >} implements Serializable {
 *         public ProcessingResult processMessages(ProcessingContext processingContext, SimulatedPump pump, Iterable{@literal <}TirePressureMessage{@literal >} messages) throws Exception {
 *             // apply the updates from the messages
 *             pump.setTirePressureReached();
 *             return ProcessingResult.UpdateDigitalTwin;
 *         }
 *     }
 * </pre>
 *
 * <p>
 * <b>Defining the pump simulation processor:</b>
 * </p>
 *
 * <p>
 *     Define the simulated pump {@link SimulationProcessor}. This piece of code will be called at each simulation interval so
 *     long as the simulation has instances to run. This pump simulation processor will send a message to the
 *     real-time car with a tire pressure change derived from the state of the simulated pump. While the simulated pump has not been
 *     told to stop, it will continue sending tire pressure changes to the real-time car.
 * </p>
 * <pre>
 *     public class PumpSimulationProcessor extends SimulationProcessor{@literal <}SimulatedPump{@literal >} implements Serializable {
 *         public ProcessingResult processModel(ProcessingContext processingContext, SimulatedPump simPump, Date date) {
 *             SimulationController controller = processingContext.getSimulationController();
 *             if(simPump.isTireFull()) {
 *                 controller.deleteThisInstance();
 *             } else {
 *                 int change = (int) (100 * simPump.getTirePressureChange());
 *                 controller.emitTelemetry("RealTimeCar", new TirePressureMessage(change));
 *             }
 *             return ProcessingResult.UpdateDigitalTwin;
 *         }
 *     }
 * </pre>
 *
 * <p>
 * <b>Using the workbench:</b>
 * </p>
 *
 * <p>
 *     The real-time and simulation models are complete. The workbench can now load up the models and then run a simulation.
 *     When beginning testing, the "step loop" is used to track the state of the twins and the simulation. Instantiate the
 *     workbench and add the models.
 * </p>
 *
 * <pre>
 *     Workbench workbench = new Workbench();
 *     workbench.addRealTimeModel("RealTimeCar", new RealTimeCarMessageProcessor(), RealTimeCar.class, TirePressureMessage.class);
 *     workbench.addSimulationModel("SimPump", new SimulatedPumpMessageProcessor(), new PumpSimulationProcessor(), SimulationPump.class, TirePressureMessage.class);
 * </pre>
 *
 * <p>
 *     The workbench is loaded up with the models. Add a single simulated pump instance.
 *     <i>Note that no real-time car digital twin is created and added to the workbench. The first message from the
 *     simulated pump digital twin will cause the workbench to create a new real-time instance.</i>
 * </p>
 * <pre>
 *     workbench.addInstance("SimPump", "23", new SimulationPump(0.29d));
 * </pre>
 *
 * <p>Initialize the simulation and then step through the simulation intervals. Start the simulation now and end the
 * simulation in 60 seconds.</p>
 *
 * <pre>
 *     SimulationStep step = workbench.initializeSimulation(System.currentTimeMillis(), System.currentTimeMillis()+60000, 1000);
 * </pre>
 *
 * <p>
 *     At each interval, view the state of the real-time car to ensure the tire pressure is changing as expected.
 * </p>
 *
 * <pre>
 *     while(step.getStatus() == SimulationStatus.Running) {
 *         step = workbench.step();
 *         HashMap{@literal <}String, DigitalTwinBase{@literal >} realTimeCars = workbench.getInstances("RealTimeCar");
 *         RealTimeCar rtCar = (RealTimeCar) realTimeCars.get("23");
 *         System.out.println("rtCar: " + rtCar.getTirePressure());
 *     }
 * </pre>
 *
 * <p>
 *     <b>Summary:</b>
 * </p>
 * <p>
 *     The simulated pump at each simulation step emits telemetry to the real-time car digital twin. With each tire pressure
 *     change message, the real-time car twin accrues state about the pressure of the tire. When the real-time car twins tire
 *     is full, it sends a message back to the simulated pump. When the simulated pump receives a message from the real-time car,
 *     it updates some internal state indicating to stop pumping. During the next simulation interval, the simulated pump
 *     deletes itself to stop pumping. This completes the simulation as there are no more remaining simulated pumps.
 * </p>
 *
 */
public class Workbench implements AutoCloseable {
    final ConcurrentHashMap<String, ConcurrentLinkedQueue<LogMessage>>                              LOGGED_MESSAGES = new ConcurrentHashMap<>();
    final ConcurrentHashMap<String, ConcurrentHashMap<String,ConcurrentLinkedQueue<AlertMessage>>>  ALERT_MESSAGES  = new ConcurrentHashMap<>();
    final ConcurrentHashMap<String, ConcurrentHashMap<String, List<String>>>                        SOURCE_MESSAGES = new ConcurrentHashMap<>();

    TwinExecutionEngine _twinExecutionEngine;
    private long _curTime, _endTime, _interval;
    private long _now, _next;
    private SimulationStep _result = null;
    private boolean _simulationStarted = false;
    private int _numWorkers = Runtime.getRuntime().availableProcessors();


    /**
     * Instantiate the workbench.
     */
    public Workbench() {
        _twinExecutionEngine = new TwinExecutionEngine(this);
    }

    /**
     * Instantiate the workbench.
     */
    public Workbench(int numSimulationWorkers) {
        _twinExecutionEngine = new TwinExecutionEngine(this);
        _numWorkers = numSimulationWorkers;
    }


    /**
     * Adds a real-time digital twin model to the workbench.
     *
     * @param modelName the name of the model.
     * @param digitalTwinMessageProcessor the model's {@link MessageProcessor} implementation. Must be marked as {@link Serializable}.
     * @param dtType the model's {@link DigitalTwinBase} implementation.
     * @param messageClass the model's message type.
     * @param <T> the type of the digital twin.
     * @param <V> the type of the message.
     * @throws WorkbenchException if any of the parameters are null or the model does not pass validation (the message
     *  processor must be serializable, and the digital twin implementation must have a parameterless constructor).
     */
    public <T extends DigitalTwinBase,V> void addRealTimeModel(String modelName, MessageProcessor<T, V> digitalTwinMessageProcessor, Class<T> dtType, Class<V> messageClass) throws WorkbenchException {
        if(modelName == null || modelName.isBlank() || modelName.isEmpty() || digitalTwinMessageProcessor == null || dtType == null || messageClass == null) {
            String errorMessage = String.format("modelName null: %b messageProcessor null: %b dtType null: %b messageType null: %b",modelName == null, digitalTwinMessageProcessor == null, dtType == null, messageClass == null);
            throw new WorkbenchException(new IllegalArgumentException("All parameters required. Found null parameter.\n" + errorMessage));
        }

        validate(digitalTwinMessageProcessor, dtType);
        _twinExecutionEngine.addDigitalTwin(modelName, digitalTwinMessageProcessor, dtType, messageClass);
    }

    /**
     * Adds a simulation digital twin model to the workbench.
     *
     * @param modelName the name of the model.
     * @param digitalTwinMessageProcessor the model's {@link MessageProcessor} implementation. Must be marked as {@link Serializable}.
     * @param simulationProcessor the model's {@link SimulationProcessor} implementation. Must be marked as {@link Serializable}.
     * @param dtType the model's {@link DigitalTwinBase} implementation.
     * @param messageClass the model's message type.
     * @param <T> the type of the digital twin.
     * @param <V> the type of the message.
     * @throws WorkbenchException if any of the parameters are null or the model does not pass validation (the message
     *  processor must be serializable, and the digital twin implementation must have a parameterless constructor).
     */
    public <T extends DigitalTwinBase,V> void addSimulationModel(String modelName, MessageProcessor<T, V> digitalTwinMessageProcessor, SimulationProcessor<T> simulationProcessor, Class<T> dtType, Class<V> messageClass) throws WorkbenchException {
        if(modelName == null || modelName.isBlank() || modelName.isEmpty() || digitalTwinMessageProcessor == null || simulationProcessor == null || dtType == null || messageClass == null) {
            String errorMessage = String.format("modelName null: %b messageProcessor null: %b simulationProcessor null: %b dtType null: %b messageType null: %b",modelName == null, digitalTwinMessageProcessor == null, simulationProcessor == null, dtType == null, messageClass == null);
            throw new WorkbenchException(new IllegalArgumentException("All parameters required. Found null parameter.\n" + errorMessage));
        }

        validate(digitalTwinMessageProcessor, dtType);
        _twinExecutionEngine.addDigitalTwin(modelName, digitalTwinMessageProcessor, simulationProcessor, dtType, messageClass, _numWorkers);
    }

    /**
     * Adds a digital twin instance to the workbench.
     * Instances cannot be added to the workbench after {@link Workbench#runSimulation(long, long, double, long)} or
     * {@link Workbench#initializeSimulation(long, long, long)} has been called.
     *
     * @param modelName the instances model.
     * @param id the instance identifier.
     * @param instance the real-time or simulation instance.
     * @throws WorkbenchException If the model does not exist or if a simulation is already running.
     */
    public void addInstance(String modelName, String id, DigitalTwinBase instance) throws WorkbenchException {
        if(_simulationStarted) throw new WorkbenchException("Cannot add new instance while simulation is active.");
        if(!_twinExecutionEngine.hasModel(modelName)) throw new WorkbenchException("The model does not exist on this workbench.");
        _twinExecutionEngine.createInstance(modelName, id, instance);
    }

    /**
     * Adds an alert provider configuration to the specified model on this workbench.
     * Alert provider configurations cannot be added to the workbench after {@link Workbench#runSimulation(long, long, double, long)} or
     * {@link Workbench#initializeSimulation(long, long, long)} has been called.
     *
     * @param modelName the instances model.
     * @param configuration the alert provider configuration.
     * @throws WorkbenchException If the model does not exist or if a simulation is already running.
     */
    public void addAlertProvider(String modelName, AlertProviderConfiguration configuration) throws WorkbenchException {
        if(_simulationStarted) throw new WorkbenchException("Cannot add new alert provider while simulation is active.");
        if(!_twinExecutionEngine.hasModel(modelName)) throw new WorkbenchException("The model does not exist on this workbench.");
        _twinExecutionEngine.addAlertProvider(modelName, configuration);
    }

    /**
     * Runs a simulation from the given startTime until the given endTime OR there is no more work to do.
     * A simulation has reached the end time when the time to run the next interval is greater than the end time or
     * there are no more simulated twins to run.
     *
     * @param startTime the start time of the simulation.
     * @param endTime the end time of the simulation.
     * @param speedup the speedup of the interval (in real-time).
     * @param interval the interval between simulation steps.
     * @return a {@link SimulationStep} that details the final runtime and the {@link SimulationStatus}.
     * @throws WorkbenchException if an exception is thrown by the simulated model or real-time model.
     */
    public SimulationStep runSimulation(long startTime, long endTime, double speedup, long interval) throws WorkbenchException {
        _twinExecutionEngine.setSimulationStatus(true);
        _simulationStarted = true;
        SimulationStep ret, result = null;
        SimulationStepArgs args;
        long now, curTime, start, end, deltaTm, delta, wait, numItv;
        args = new SimulationStepArgs(startTime, interval, WorkbenchSimulationFlags.Start);
        _twinExecutionEngine.runSimulationStep(args);
        SimulationStatus status = SimulationStatus.Running;
        now = curTime = startTime;
        while(status == SimulationStatus.Running &&
              curTime < endTime) {
            args    = new SimulationStepArgs(curTime, interval, WorkbenchSimulationFlags.Run);
            now     = curTime;
            start   = System.currentTimeMillis();
            result  = _twinExecutionEngine.runSimulationStep(args);
            end     = System.currentTimeMillis();
            delta   = result.getTime() - curTime;
            numItv  = delta/interval;
            numItv  = delta%numItv != 0 ? numItv+1 : numItv;
            deltaTm = end-start;
            wait    = deltaTm >= interval ? 0L : (long)((interval-deltaTm)/speedup);
            status  = result.getStatus();
            curTime = curTime+(numItv*interval);
            try {
                Thread.sleep(wait);
            } catch (Exception e) {
                throw new WorkbenchException(e);
            }
        }
        if(curTime >= endTime) {
            ret = new SimulationStep(SimulationStatus.EndTimeReached, curTime);
            _twinExecutionEngine.setSimulationStatus(false);
            _simulationStarted = false;
        } else {
            ret = new SimulationStep(result.getStatus(), now);
            _twinExecutionEngine.setSimulationStatus(false);
            _simulationStarted = false;
        }
        return ret;
    }

    /**
     * Initializes the simulation so that each interval can be run separately by calling the {@link Workbench#step()}
     * function.
     *
     * @param startTime the start time of the simulation.
     * @param endTime the end time of the simulation.
     * @param interval the interval between simulation steps.
     * @return a {@link SimulationStep} that details the startTime and the {@link SimulationStatus} -- which will always be {@link SimulationStatus#Running}.
     */
    public SimulationStep initializeSimulation(long startTime, long endTime, long interval) {
        _simulationStarted = true;
        _twinExecutionEngine.setSimulationStatus(true);
        _curTime    = startTime;
        _endTime    = endTime;
        _interval   = interval;
        _result     = new SimulationStep(SimulationStatus.Running, startTime);
        _twinExecutionEngine.setSimulationStatus(true);
        return _result;
    }

    /**
     * Run the next simulation interval.
     *
     * @return a {@link SimulationStep} that shows the time interval that was run and the corresponding {@link SimulationStatus}
     * @throws WorkbenchException if an exception is thrown by the simulated model or real-time model.
     */
    public SimulationStep step() throws WorkbenchException {
        long delta, numItv;
        SimulationStatus status = _result.getStatus();
        if(status == SimulationStatus.Running ) {
            if(_curTime >= _endTime) {
                _simulationStarted = false;
                _twinExecutionEngine.setSimulationStatus(false);
                return new SimulationStep(SimulationStatus.EndTimeReached, _curTime);
            }
            SimulationStepArgs args = new SimulationStepArgs(_curTime, _interval, WorkbenchSimulationFlags.Run);
            _now        = _curTime;
            _result     = _twinExecutionEngine.runSimulationStep(args);
            delta       = _result.getTime() - _curTime;
            numItv      = delta/_interval;
            numItv      = delta%numItv != 0 ? numItv+1 : numItv;
            _curTime    = _curTime+(numItv*_interval);
            _next       = _curTime;
            return new SimulationStep(_result.getStatus(), _now);
        } else {
            _simulationStarted = false;
            _twinExecutionEngine.setSimulationStatus(false);
            throw new WorkbenchException("Simulation is inactive. Simulation status: " + _result.getStatus());
        }
    }

    /**
     * Retrieves the current time interval of the simulation.
     * @return a {@link Date} representation for the current interval time for the simulation.
     * @throws WorkbenchException if the simulation is not started or initialized.
     */
    public Date getTime() throws WorkbenchException {
        if(_simulationStarted) {
            return new Date(_now);
        }
        throw new WorkbenchException("Simulation is not started");

    }

    /**
     * Retrieves the next interval time of the simulation.
     * @return a {@link Date} representation for the next interval time for the simulation.
     * @throws WorkbenchException if the simulation is not started or initialized.
     */
    public Date peek() throws WorkbenchException {
        if(_simulationStarted) {
            return new Date(_next);
        }
        throw new WorkbenchException("Simulation is not started");
    }

    /**
     * Retrieves DigitalTwin instances for a given model.
     *
     * @param modelName the digital twin model name
     * @return the instances associated with the parameter model
     * @throws WorkbenchException if an exception occurs while retrieving digital twin instances for the parameter modelName
     */
    public HashMap<String, DigitalTwinBase> getInstances(String modelName) throws WorkbenchException {
        if(_twinExecutionEngine.getTwinInstances(modelName) == null)
            throw new WorkbenchException(String.format("No instances for model %s.", modelName));
        return _twinExecutionEngine.getTwinInstances(modelName);
    }

    /**
     * Retrieves messages logged by digital twin instances for a specified mdoel. If the provided timestamp is 0, all messages will be returned.
     * Timestamps greater than 0 will return a sublist of logged messages where the first message in the returned list
     * will be greater than the provided timestamp. If no messages exist after the timestamp, the returned list will be
     * empty.
     *
     * @param model     the model name for the logged messages.
     * @param timestamp the timestamp used to filter the retrieved list.
     * @return the list of messages defined by the timestamp
     */
    public List<LogMessage> getLoggedMessages(String model, long timestamp) {
        if(timestamp == 0L) {
            return Arrays.asList(LOGGED_MESSAGES.getOrDefault(model, new ConcurrentLinkedQueue<>()).toArray(new LogMessage[0]));
        } else {
            ConcurrentLinkedQueue<LogMessage> modelMessages = LOGGED_MESSAGES.getOrDefault(model, new ConcurrentLinkedQueue<>());
            int endIdx = modelMessages.size()-1;
            int bgnIdx = -1;
            for(LogMessage msg : modelMessages) {
                if(msg.getTimestamp() <= timestamp) {
                    bgnIdx++;
                } else {
                    break;
                }
            }

            if(endIdx == bgnIdx) {
                return Collections.emptyList();
            } else if(bgnIdx == -1){
                return Arrays.asList(LOGGED_MESSAGES.getOrDefault(model, new ConcurrentLinkedQueue<>()).toArray(new LogMessage[0]));
            }

            return Arrays.asList(modelMessages.toArray(new LogMessage[0])).subList(bgnIdx, endIdx);
        }
    }

    /**
     * Retrieves alert messages from digital twin instances.
     *
     * @param model the model to retrieve alert messages from.
     * @param alertProvider the alert provider that generated the alerts.
     * @return the list of alert messages generated by digital twin instances.
     * @throws WorkbenchException if an exception occurs while retrieving logged messages.
     */
    public List<AlertMessage> getAlertMessages(String model, String alertProvider) throws WorkbenchException {
        if(!_twinExecutionEngine.hasModel(model)) throw new WorkbenchException(String.format("No registered model with name %s found.", model));
        if(!_twinExecutionEngine.hasAlertProviderConfiguration(model, alertProvider)) throw new WorkbenchException(String.format("No alert provider configuration, registered for model %s, for %s found.", model, alertProvider));

        ConcurrentHashMap<String, ConcurrentLinkedQueue<AlertMessage>> perModelMessages = ALERT_MESSAGES.getOrDefault(model, new ConcurrentHashMap<>());
        return Arrays.asList(perModelMessages.get(alertProvider).toArray(new AlertMessage[0]));
    }

    public SharedData getSharedModelData(String model) throws WorkbenchException {
        if(_twinExecutionEngine.hasModel(model)) {
            return new WorkbenchSharedData(_twinExecutionEngine.getModelData(model));
        } else {
            throw new WorkbenchException("Workbench does not contain model " + model);
        }
    }

    public SharedData getSharedGlobalData(String model) throws WorkbenchException {
        return new WorkbenchSharedData(_twinExecutionEngine.getGlobalSharedData());
    }

    /**
     * Generates a ModelSchema for the defined model
     *
     * @param modelName the digital twin model's name to generate a schema.
     * @return a JSON string of the model's schema
     * @throws WorkbenchException if an exception occurs while generating a model schema.
     */
    public String generateModelSchema(String modelName) throws WorkbenchException {
        if(_twinExecutionEngine.runningModels().contains(modelName)) {
            return _twinExecutionEngine.generateModelSchema(modelName);
        }
        throw new WorkbenchException("Model is not loaded; cannot generate model schema.");
    }

    /**
     * Generates a ModelSchema for the parameter modelName and writes the schema to a file on the file system. If the
     * parameter outputDirectory is null the file will be written to the working directory of the JVM.
     *
     * @param modelName the name of the digital twin model
     * @param outputDirectory the directory to write the file to, or null to write the file to the current working directory.
     * @return the full file path of the model.json schema file
     * @throws WorkbenchException if an exception occurs while generating a model schema.
     */
    public String generateModelSchema(String modelName, String outputDirectory) throws WorkbenchException {
        if(modelName == null || modelName.isEmpty()) {
            throw new WorkbenchException("Required parameters: modelName.", new IllegalArgumentException());
        }

        outputDirectory = outputDirectory == null ? System.getProperty("user.dir") : outputDirectory;

        if(_twinExecutionEngine.runningModels().contains(modelName)) {
            try {
                String filePath = String.format("%s\\model.json", outputDirectory);
                FileWriter fileWriter = new FileWriter(filePath);
                fileWriter.write(_twinExecutionEngine.generateModelSchema(modelName));
                fileWriter.flush();
                fileWriter.close();
                return filePath;
            } catch (IOException e) {
                throw new WorkbenchException("Could not write file to file system.", e);
            }

        }
        throw new WorkbenchException("Model is not loaded; cannot generate model schema.");
    }

    /**
     * Send a list of messages to a real-time or simulation model.
     * @param modelName The model name.
     * @param id the instance id.
     * @param messages the messages to send.
     * @return {@link SendingResult#Handled} unless an exception is thrown.
     * @throws WorkbenchException if model name, id, or messages are null. Also thrown if the model's {@link MessageProcessor#processMessages(ProcessingContext, DigitalTwinBase, Iterable)}
     * throws an exception.
     */
    public SendingResult send(String modelName, String id, List<Object> messages) throws WorkbenchException {
        if(modelName == null || id == null || messages == null) {
            throw new WorkbenchException("ModelName, Id, and messages are required.");
        }
        if(_twinExecutionEngine.hasModel(modelName) && !_simulationStarted) {
            _twinExecutionEngine.run(modelName, id, null, messages);
        } else {
            String msg = _twinExecutionEngine.hasModel(modelName) ? String.format("Cannot send message to %s. Simulation is active.", modelName) : String.format("Cannot send message to %s. Model does not exist.", modelName);
            throw new WorkbenchException(msg);
        }
        return SendingResult.Handled;
    }

//    /**
//     * Sends a single JSON serialized UTF-8 string message to a digital twin.
//     *
//     * @param modelName the name of the digital twin model
//     * @param id the ID of the digital twin model
//     * @param jsonSerializedMessage the serialized JSON UTF-8 string message
//     * @return the sending result
//     * @throws WorkbenchException if an exception is thrown by the twin or an error occurs while processing.
//     */
//    public SendingResult send(String modelName, String id, String jsonSerializedMessage) throws WorkbenchException {
//        List<String> msgs = new ArrayList<>();
//        msgs.add(jsonSerializedMessage);
//        return send(modelName, id, msgs);
//    }
//
//    /**
//     *
//     * @param modelName the name of the digital twin model
//     * @param id the ID of the digital twin model
//     * @param jsonSerializedMessages a serialized list of JSON UTF-8 string messages
//     * @return the sending result
//     * @throws WorkbenchException if an exception occurs while sending a message
//     */
//    public SendingResult send(String modelName, String id, List<String> jsonSerializedMessages) throws WorkbenchException {
//        return sendMessage(modelName, id, jsonSerializedMessages) != null ? SendingResult.Handled : SendingResult.NotHandled;
//    }

    ProcessingResult sendMessage(String model, String id, List<String> jsonMessages) throws WorkbenchException {
        if(_simulationStarted) throw new WorkbenchException("Cannot send message; simulation is active.");
        StringBuilder serializedListBuilder = new StringBuilder(String.format("[%s", jsonMessages.remove(0)));
        for(String msg : jsonMessages) {
            serializedListBuilder.append(",");
            serializedListBuilder.append(msg);

        }
        serializedListBuilder.append("]");
        return _twinExecutionEngine.run(model, id, null, serializedListBuilder.toString());
    }


    static <T extends DigitalTwinBase, V> void validate(MessageProcessor<T, V> digitalTwinMessageProcessor, Class<T> dtType) throws WorkbenchException {
        WorkbenchException mee = null;

        ByteArrayOutputStream baos = null;
        ObjectOutputStream oos = null;

        ByteArrayInputStream bais = null;
        ObjectInputStream ois = null;
        boolean serialized = false;
        try {
            // serialize MessageProcessor
            baos = new ByteArrayOutputStream();
            oos = new ObjectOutputStream(baos);
            oos.writeObject(digitalTwinMessageProcessor);

            byte[] serializedMP = baos.toByteArray();
            serialized = true;

            bais = new ByteArrayInputStream(serializedMP);
            ois = new ObjectInputStream(bais);
            MessageProcessor<T,V> incoming = (MessageProcessor<T,V>) ois.readObject();
        } catch (Exception all) {
            if(serialized)
                throw new WorkbenchException("Could not deserialize MessageProcessor instance.", all);
            else
                throw new WorkbenchException("Could not serialize MessageProcessor instance", all);
        } finally {
            try {
                if(baos != null) {
                    baos.flush();
                    baos.close();
                }
                if(oos != null) {
                    oos.flush();
                    oos.close();
                }

                if(bais != null) {
                    bais.close();
                }
                if(ois != null) {
                    ois.close();
                }
            } catch(Exception any) {} // best effort to cleanup
        }

        try {
            Class<? extends MessageProcessor> mpType = digitalTwinMessageProcessor.getClass();
            // instantiate TwinInstance
            MessageProcessor instance = mpType.getConstructor().newInstance();
        } catch (Exception e) {
            throw new WorkbenchException("Could not instantiate MessageProcessor instance. Default constructor required.", e);
        }

        try {
            // instantiate TwinInstance
            DigitalTwinBase instance = dtType.getConstructor().newInstance();
        } catch (Exception e) {
            throw new WorkbenchException("Could not instantiate DigitalTwin instance. Default constructor required.", e);
        }
    }

    public void addSharedModelData(String modelName, String key, byte[] value) {
        _twinExecutionEngine.getModelData(modelName).put(key, value);
    }

    public void addGlobalModelData(String key, byte[] value) {
        _twinExecutionEngine.getGlobalSharedData().put(key, value);
    }

    @Override
    public void close() throws Exception {
        _twinExecutionEngine.close();
    }
}
